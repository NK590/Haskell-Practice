import Data.Char

-- 1-1.
-- 3:[True, False]는 3이 정수형, [True, False]는 boolean형의 리스트이기 때문에 연산 불가능.

-- 1-2.
cons8 :: [Integer] -> [Integer]
cons8 = (:) 8

-- 1-3.
back8 :: Num a => [a] -> [a]
back8 x = x ++ [8]

-- 1-4.
myCons :: [a] -> a -> [a]
myCons list thing = thing : list

-- 2-1.
-- 1) [1, 2, 3, []] = 1:2:3:[]:[]
-- 2) [1, [2, 3], 4] -> 유효하지 않은 표기
-- 3) [[1, 2, 3], []] = (1:2:3:[]):[]:[]

-- 2-2
-- 1) []:[[1, 2, 3], [4, 5, 6]] = [[], [1, 2, 3], [4, 5, 6]]
-- 2) []:[] = [[]]
-- 3) []:[]:[] = [[], []]
-- 4) [1]:[]:[] = [[1], []]
-- 5) ["hi"]:[1]:[] -> 유효하지 않은 표기

-- 2-3
-- 하스켈에서 리스트의 리스트의 리스트를 만들 수 있는가? -> 가능
-- [[1, 2], 3, [4, 5]] -> [1, 2]와 [4, 5]는 list형이지만 3은 정수형이므로 유효하지 않음. [[1, 2], [3], [4, 5]]는 가능.

-- 3-1
myTuple = (4, "hello", True)

-- 3-2
-- Tuple의 각각의 원소는 어떤 타입이든 올 수 있으므로, 전부 유효한 표기임

-- 3-3
-- 1) Tuple의 각 원소 타입에 제한이 없으므로, return되는 타입이 제각각이어서 함수형 프로그래밍 원칙에 위배될 수 있다.
-- 2) 다른 타입의 Tuple이 나올 것이다.

-- 4-1
-- 1) 1:(2,3) -> 무효
-- 2) (2,4):(2,3) -> 무효
-- 3) (2,4):[] -> [(2, 4)]
-- 4) [(2,4),(5,5),('a','b')] -> 무효
-- 5) ([2,4],[2,2]) -> 유효

-- 5-1
pick4 = snd (fst (("Hello", 4), True))

-- 5-2
-- ('a', 4) 등은 Tuple의 원소 타입에 제한이 없으므로 가능한 표기법이다.

-- 5-3
headTail :: [a] -> (a, [a])
headTail list = (head list, tail list)

-- 5-4
pickFifth :: [a] -> a
pickFifth list = head (tail (tail (tail (tail list))))
-- 위 구현은 리스트의 원소 개수가 5개 미만이면 error를 발생시킨다.

-- 6-1, 6-2는 위에서 이미 구현하였다.
h :: Int -> a -> b -> Char
h x y z = chr (x - 2)

main :: IO()
main = do
    print(cons8 [1, 2])
    print(back8 [1, 2])
    print(myCons [1, 2] 10)
    print(pick4)
    print(headTail [1, 2, 3])
    print(h 10 20 30)